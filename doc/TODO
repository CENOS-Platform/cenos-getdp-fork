$Id: TODO,v 1.4 2006-03-16 01:18:00 geuzaine Exp $

*******************************************************************

Move the optional code (Arpack, Sparksit?, NR) into new contrib/
directory

*******************************************************************

Check if we explain this somewhere in the docs:

a "Dof" (degree of freedom) term must be written in such a way that
the Dof value multiplies the whole term. In the code the (unknown)
value of the degree of freedom simply multiplies the whole expression,
a posteriori.

This implies that this is correct:

Galerkin { [ alpha[] * Dof{T} , {T} ];
           In Convection; Integration I1; Jacobian JSur;  }
Galerkin { [ -alpha[] * 348 , {T} ];
           In Convection; Integration I1; Jacobian JSur;  } 

but this is not:

Galerkin { [ alpha[] * (Dof{T} - 348) , {T} ];
           In Convection; Integration I1; Jacobian JSur;  } 

*******************************************************************

Explain more clearly the difference between Dof{qty} and {qty}, with
an example:

Galerkin { [ hr[{T}] * (({T}+273.)4-(TConv[]+273.)4) , {T} ] ;
             In SurRad_The ; Integration I1; Jacobian JSur;  }

"In GetDP, a formulation represents a discrete linear operator (linear
with respect to the Dofs). So you cannot write Dof{T}4, as this would
lead to a nonlinear equation in terms of Dof{T}.

If you have a nonlinear equation, you need to write a linearized form
in the formulation. In the example above we linearize the equation by
using functional (or "Picard") iteration, where we get the next value
of the unknown by plugging the value obtained at the previous
iteration into the equation (the previous value is known, and is
accessed with "{T}", without "Dof"). You could also use a
Newton-Raphson iteration by adding a "JacNL" term (see the wiki for an
example)."

********************************************************************

Arguments in nested expressions don't work. A workaround is to store
the arguments in registers (i.e. with '#1'-like commands).

********************************************************************

Global quantities have to be defined on "single" regions, i.e. regions
of type aa = Region[num].

********************************************************************

Should recompute Current.x,y,z in Cal_vBFxDof??

********************************************************************

Andre Nicolet <andre.nicolet@fresnel.fr>

* generalize localterm (equation part should call Cal_vBFxDof)

* add field in Data_Function for vector-valued basis functions:
generalized gradient

* define x, y and z derivatives of vector-valued basis functions

* define a 'generalized gradient' basis function based on these
partial derivatives (warning: change of ccords!)

* generalize Cal_Galerkin, Get_FunctionValue, etc. so that they accept
the tensor values retuned by the generalized gradient
